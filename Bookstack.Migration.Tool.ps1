#Requires -Version 5.1
Set-StrictMode -Version Latest; $ErrorActionPreference = "Continue"; $VerbosePreference = "Continue"; $DebugPreference = "Continue"
function Write-DebugLog { param([string]$Message, [string]$Level = "DEBUG", [ConsoleColor]$Color = [ConsoleColor]::Gray); $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss.fff"; $levelColors = @{"DEBUG"=[ConsoleColor]::DarkGray; "INFO"=[ConsoleColor]::Cyan; "SUCCESS"=[ConsoleColor]::Green; "WARN"=[ConsoleColor]::Yellow; "ERROR"=[ConsoleColor]::Red}; $displayColor = if ($levelColors.ContainsKey($Level)) { $levelColors[$Level] } else { $Color }; Write-Host "[$timestamp] [$Level] $Message" -ForegroundColor $displayColor }
Write-DebugLog "Starting BookStack Migration Tool..." -Level "INFO"; Write-DebugLog "PowerShell Version: $($PSVersionTable.PSVersion)" -Level "DEBUG"; Write-DebugLog "Loading assemblies..." -Level "DEBUG"
try { Add-Type -AssemblyName PresentationFramework; Add-Type -AssemblyName PresentationCore; Add-Type -AssemblyName WindowsBase; Add-Type -AssemblyName System.Windows.Forms; Write-DebugLog "Assemblies loaded successfully" -Level "SUCCESS" } catch { Write-DebugLog "Failed to load assemblies: $_" -Level "ERROR"; throw }
Write-DebugLog "Loading XAML definition..." -Level "DEBUG"
[xml]$XAML = @"
<Window xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation" xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" Title="BookStack Migration Tool v2.5" Height="950" Width="1250" WindowStartupLocation="CenterScreen" WindowState="Maximized" Background="#f5f5f5">
<Window.Resources>
<Style TargetType="Button"><Setter Property="Background" Value="#0078d4"/><Setter Property="Foreground" Value="White"/><Setter Property="BorderThickness" Value="0"/><Setter Property="Padding" Value="15,8"/><Setter Property="Margin" Value="5"/><Setter Property="Cursor" Value="Hand"/><Setter Property="FontSize" Value="13"/><Setter Property="Template"><Setter.Value><ControlTemplate TargetType="Button"><Border Background="{TemplateBinding Background}" CornerRadius="4" Padding="{TemplateBinding Padding}"><ContentPresenter HorizontalAlignment="Center" VerticalAlignment="Center"/></Border></ControlTemplate></Setter.Value></Setter><Style.Triggers><Trigger Property="IsMouseOver" Value="True"><Setter Property="Background" Value="#1a86d9"/></Trigger><Trigger Property="IsEnabled" Value="False"><Setter Property="Background" Value="#cccccc"/><Setter Property="Foreground" Value="#888888"/></Trigger></Style.Triggers></Style>
<Style TargetType="TextBox"><Setter Property="Background" Value="#ffffff"/><Setter Property="Foreground" Value="#1e1e1e"/><Setter Property="BorderBrush" Value="#cccccc"/><Setter Property="BorderThickness" Value="1"/><Setter Property="Padding" Value="8,6"/><Setter Property="FontSize" Value="13"/><Setter Property="CaretBrush" Value="Black"/></Style>
<Style TargetType="PasswordBox"><Setter Property="Background" Value="#ffffff"/><Setter Property="Foreground" Value="#1e1e1e"/><Setter Property="BorderBrush" Value="#cccccc"/><Setter Property="BorderThickness" Value="1"/><Setter Property="Padding" Value="8,6"/><Setter Property="FontSize" Value="13"/><Setter Property="CaretBrush" Value="Black"/></Style>
<Style TargetType="Label"><Setter Property="Foreground" Value="#1e1e1e"/><Setter Property="FontSize" Value="13"/><Setter Property="Margin" Value="0,0,0,3"/></Style>
<Style TargetType="CheckBox"><Setter Property="Foreground" Value="#1e1e1e"/><Setter Property="FontSize" Value="13"/><Setter Property="Margin" Value="5"/></Style>
<Style TargetType="GroupBox"><Setter Property="BorderBrush" Value="#cccccc"/><Setter Property="Foreground" Value="#1e1e1e"/><Setter Property="Margin" Value="5"/><Setter Property="Padding" Value="10"/><Setter Property="Background" Value="#fafafa"/></Style>
</Window.Resources>
<Grid><Grid.RowDefinitions><RowDefinition Height="Auto"/><RowDefinition Height="*"/><RowDefinition Height="Auto"/></Grid.RowDefinitions>
<Border Grid.Row="0" Background="#0078d4" Padding="20,15"><Grid><Grid.ColumnDefinitions><ColumnDefinition Width="*"/><ColumnDefinition Width="Auto"/></Grid.ColumnDefinitions><StackPanel><TextBlock Text="📚 BookStack Migration Tool" FontSize="24" FontWeight="Bold" Foreground="White"/><TextBlock Text="Export and Import content between BookStack instances - Enhanced with Delete Feature" FontSize="13" Foreground="#cce5ff" Margin="0,5,0,0"/></StackPanel><StackPanel Grid.Column="1" Orientation="Horizontal" VerticalAlignment="Center"><TextBlock x:Name="txtStatus" Text="Ready" Foreground="White" FontSize="13" VerticalAlignment="Center" Margin="0,0,10,0"/><Ellipse x:Name="statusIndicator" Width="12" Height="12" Fill="#10b981"/></StackPanel></Grid></Border>
<TabControl Grid.Row="1" Background="#f5f5f5" BorderThickness="0" Margin="10">
<TabItem Header="🔌 Connections" Background="#e8e8e8" Foreground="#1e1e1e"><ScrollViewer VerticalScrollBarVisibility="Auto"><Grid Margin="10"><Grid.RowDefinitions><RowDefinition Height="Auto"/><RowDefinition Height="Auto"/><RowDefinition Height="Auto"/></Grid.RowDefinitions><Grid.ColumnDefinitions><ColumnDefinition Width="*"/><ColumnDefinition Width="*"/></Grid.ColumnDefinitions>
<GroupBox Grid.Row="0" Grid.Column="0" Header="📤 Source Instance (Export From)" Margin="5"><StackPanel Margin="10"><Label Content="BookStack URL:"/><TextBox x:Name="txtSourceUrl" Text="https://old-bookstack.example.com"/><Label Content="API Token ID:" Margin="0,10,0,0"/><TextBox x:Name="txtSourceTokenId"/><Label Content="API Token Secret:" Margin="0,10,0,0"/><PasswordBox x:Name="txtSourceTokenSecret"/><Label Content="Detected Version:" Margin="0,10,0,0"/><TextBox x:Name="txtSourceVersion" IsReadOnly="True" Text="Unknown"/><StackPanel Orientation="Horizontal" Margin="0,15,0,0"><Button x:Name="btnTestSource" Content="🔍 Test Connection" Width="150"/><TextBlock x:Name="txtSourceStatus" VerticalAlignment="Center" Margin="10,0,0,0" Foreground="#666"/></StackPanel><GroupBox Header="Available APIs" Margin="0,15,0,0" Padding="10"><Grid><Grid.ColumnDefinitions><ColumnDefinition Width="*"/><ColumnDefinition Width="*"/></Grid.ColumnDefinitions><Grid.RowDefinitions><RowDefinition Height="Auto"/><RowDefinition Height="Auto"/><RowDefinition Height="Auto"/></Grid.RowDefinitions><TextBlock x:Name="apiShelves" Grid.Row="0" Grid.Column="0" Text="⬜ Shelves" Foreground="#666" Margin="5"/><TextBlock x:Name="apiBooks" Grid.Row="0" Grid.Column="1" Text="⬜ Books" Foreground="#666" Margin="5"/><TextBlock x:Name="apiChapters" Grid.Row="1" Grid.Column="0" Text="⬜ Chapters" Foreground="#666" Margin="5"/><TextBlock x:Name="apiPages" Grid.Row="1" Grid.Column="1" Text="⬜ Pages" Foreground="#666" Margin="5"/><TextBlock x:Name="apiAttachments" Grid.Row="2" Grid.Column="0" Text="⬜ Attachments" Foreground="#666" Margin="5"/><TextBlock x:Name="apiImages" Grid.Row="2" Grid.Column="1" Text="⬜ Images" Foreground="#666" Margin="5"/></Grid></GroupBox></StackPanel></GroupBox>
<GroupBox Grid.Row="0" Grid.Column="1" Header="📥 Target Instance (Import To)" Margin="5"><StackPanel Margin="10"><Label Content="BookStack URL:"/><TextBox x:Name="txtTargetUrl" Text="https://new-bookstack.example.com"/><Label Content="API Token ID:" Margin="0,10,0,0"/><TextBox x:Name="txtTargetTokenId"/><Label Content="API Token Secret:" Margin="0,10,0,0"/><PasswordBox x:Name="txtTargetTokenSecret"/><Label Content="Detected Version:" Margin="0,10,0,0"/><TextBox x:Name="txtTargetVersion" IsReadOnly="True" Text="Unknown"/><StackPanel Orientation="Horizontal" Margin="0,15,0,0"><Button x:Name="btnTestTarget" Content="🔍 Test Connection" Width="150"/><TextBlock x:Name="txtTargetStatus" VerticalAlignment="Center" Margin="10,0,0,0" Foreground="#666"/></StackPanel><GroupBox Header="Available APIs" Margin="0,15,0,0" Padding="10"><Grid><Grid.ColumnDefinitions><ColumnDefinition Width="*"/><ColumnDefinition Width="*"/></Grid.ColumnDefinitions><Grid.RowDefinitions><RowDefinition Height="Auto"/><RowDefinition Height="Auto"/><RowDefinition Height="Auto"/></Grid.RowDefinitions><TextBlock x:Name="apiTargetShelves" Grid.Row="0" Grid.Column="0" Text="⬜ Shelves" Foreground="#666" Margin="5"/><TextBlock x:Name="apiTargetBooks" Grid.Row="0" Grid.Column="1" Text="⬜ Books" Foreground="#666" Margin="5"/><TextBlock x:Name="apiTargetChapters" Grid.Row="1" Grid.Column="0" Text="⬜ Chapters" Foreground="#666" Margin="5"/><TextBlock x:Name="apiTargetPages" Grid.Row="1" Grid.Column="1" Text="⬜ Pages" Foreground="#666" Margin="5"/><TextBlock x:Name="apiTargetAttachments" Grid.Row="2" Grid.Column="0" Text="⬜ Attachments" Foreground="#666" Margin="5"/><TextBlock x:Name="apiTargetImages" Grid.Row="2" Grid.Column="1" Text="⬜ Images" Foreground="#666" Margin="5"/></Grid></GroupBox></StackPanel></GroupBox>
<GroupBox Grid.Row="1" Grid.ColumnSpan="2" Header="📁 Export Location" Margin="5"><Grid Margin="10"><Grid.ColumnDefinitions><ColumnDefinition Width="*"/><ColumnDefinition Width="Auto"/></Grid.ColumnDefinitions><TextBox x:Name="txtExportPath" Text="C:\BookStackExport"/><Button x:Name="btnBrowse" Grid.Column="1" Content="📂 Browse" Width="100"/></Grid></GroupBox>
<GroupBox Grid.Row="2" Grid.ColumnSpan="2" Header="💾 Configuration" Margin="5"><StackPanel Orientation="Horizontal" Margin="10"><Button x:Name="btnSaveConfig" Content="💾 Save Configuration"/><Button x:Name="btnLoadConfig" Content="📂 Load Configuration"/><Button x:Name="btnClearLog" Content="🗑️ Clear Console Log" Background="#6b6b6b"/></StackPanel></GroupBox></Grid></ScrollViewer></TabItem>
<TabItem Header="📤 Export" Background="#e8e8e8" Foreground="#1e1e1e"><Grid Margin="10"><Grid.RowDefinitions><RowDefinition Height="Auto"/><RowDefinition Height="Auto"/><RowDefinition Height="*"/><RowDefinition Height="Auto"/></Grid.RowDefinitions>
<GroupBox Grid.Row="0" Header="Export Options" Margin="5"><StackPanel Margin="10"><WrapPanel><CheckBox x:Name="chkExportShelves" Content="📚 Shelves" IsChecked="True"/><CheckBox x:Name="chkExportBooks" Content="📖 Books" IsChecked="True"/><CheckBox x:Name="chkExportChapters" Content="📑 Chapters" IsChecked="True"/><CheckBox x:Name="chkExportPages" Content="📄 Pages" IsChecked="True"/><CheckBox x:Name="chkExportAttachments" Content="📎 Attachments" IsChecked="True"/><CheckBox x:Name="chkExportImages" Content="🖼️ Images" IsChecked="True"/></WrapPanel><WrapPanel Margin="0,10,0,0"><CheckBox x:Name="chkDownloadAttachmentFiles" Content="📥 Download attachment files" IsChecked="True"/><CheckBox x:Name="chkDownloadImageFiles" Content="📥 Download image files" IsChecked="True"/><CheckBox x:Name="chkExportCoverImages" Content="📷 Export cover images" IsChecked="True"/></WrapPanel></StackPanel></GroupBox>
<GroupBox Grid.Row="1" Header="📊 Content Summary (Click Refresh)" Margin="5"><Grid Margin="10"><Grid.ColumnDefinitions><ColumnDefinition Width="*"/><ColumnDefinition Width="*"/><ColumnDefinition Width="*"/><ColumnDefinition Width="*"/><ColumnDefinition Width="*"/><ColumnDefinition Width="*"/><ColumnDefinition Width="Auto"/></Grid.ColumnDefinitions><StackPanel Grid.Column="0" HorizontalAlignment="Center"><TextBlock Text="Shelves" Foreground="#666" HorizontalAlignment="Center"/><TextBlock x:Name="txtShelvesCount" Text="--" FontSize="24" Foreground="#0078d4" HorizontalAlignment="Center"/></StackPanel><StackPanel Grid.Column="1" HorizontalAlignment="Center"><TextBlock Text="Books" Foreground="#666" HorizontalAlignment="Center"/><TextBlock x:Name="txtBooksCount" Text="--" FontSize="24" Foreground="#0078d4" HorizontalAlignment="Center"/></StackPanel><StackPanel Grid.Column="2" HorizontalAlignment="Center"><TextBlock Text="Chapters" Foreground="#666" HorizontalAlignment="Center"/><TextBlock x:Name="txtChaptersCount" Text="--" FontSize="24" Foreground="#0078d4" HorizontalAlignment="Center"/></StackPanel><StackPanel Grid.Column="3" HorizontalAlignment="Center"><TextBlock Text="Pages" Foreground="#666" HorizontalAlignment="Center"/><TextBlock x:Name="txtPagesCount" Text="--" FontSize="24" Foreground="#0078d4" HorizontalAlignment="Center"/></StackPanel><StackPanel Grid.Column="4" HorizontalAlignment="Center"><TextBlock Text="Attachments" Foreground="#666" HorizontalAlignment="Center"/><TextBlock x:Name="txtAttachmentsCount" Text="--" FontSize="24" Foreground="#0078d4" HorizontalAlignment="Center"/></StackPanel><StackPanel Grid.Column="5" HorizontalAlignment="Center"><TextBlock Text="Images" Foreground="#666" HorizontalAlignment="Center"/><TextBlock x:Name="txtImagesCount" Text="--" FontSize="24" Foreground="#0078d4" HorizontalAlignment="Center"/></StackPanel><StackPanel Grid.Column="6" VerticalAlignment="Center"><Button x:Name="btnRefreshCounts" Content="🔄 Refresh" Background="#505050"/></StackPanel></Grid></GroupBox>
<GroupBox Grid.Row="2" Header="📋 Export Log" Margin="5"><Grid><Grid.RowDefinitions><RowDefinition Height="Auto"/><RowDefinition Height="*"/></Grid.RowDefinitions><StackPanel Grid.Row="0" Margin="10,10,10,5"><TextBlock x:Name="txtExportCurrentItem" Text="Ready to export..." Foreground="#1e1e1e"/><ProgressBar x:Name="progressExport" Height="20" Margin="0,5,0,0" Background="#e0e0e0" Foreground="#0078d4" Value="0" Maximum="100"/><TextBlock x:Name="txtExportProgress" Text="0%" HorizontalAlignment="Center" Foreground="#666" Margin="0,3,0,0"/></StackPanel><TextBox x:Name="txtExportLog" Grid.Row="1" IsReadOnly="True" VerticalScrollBarVisibility="Auto" HorizontalScrollBarVisibility="Auto" TextWrapping="Wrap" FontFamily="Consolas" FontSize="11" Background="#ffffff" Margin="10,5,10,10"/></Grid></GroupBox>
<StackPanel Grid.Row="3" Orientation="Horizontal" HorizontalAlignment="Right" Margin="5"><Button x:Name="btnExport" Content="▶️ Start Export" Width="150" Background="#107c10"/><Button x:Name="btnCancelExport" Content="⏹️ Cancel" Width="100" Background="#d41a1a" IsEnabled="False"/></StackPanel></Grid></TabItem>
<TabItem Header="📥 Import" Background="#e8e8e8" Foreground="#1e1e1e"><Grid Margin="10"><Grid.RowDefinitions><RowDefinition Height="Auto"/><RowDefinition Height="Auto"/><RowDefinition Height="*"/><RowDefinition Height="Auto"/></Grid.RowDefinitions>
<GroupBox Grid.Row="0" Header="Import Options" Margin="5"><StackPanel Margin="10"><WrapPanel><CheckBox x:Name="chkImportShelves" Content="📚 Shelves" IsChecked="True"/><CheckBox x:Name="chkImportBooks" Content="📖 Books" IsChecked="True"/><CheckBox x:Name="chkImportChapters" Content="📑 Chapters" IsChecked="True"/><CheckBox x:Name="chkImportPages" Content="📄 Pages" IsChecked="True"/><CheckBox x:Name="chkImportAttachments" Content="📎 Attachments" IsChecked="True"/><CheckBox x:Name="chkImportImages" Content="🖼️ Images" IsChecked="True"/></WrapPanel><WrapPanel Margin="0,10,0,0"><CheckBox x:Name="chkSkipExisting" Content="Skip existing items" IsChecked="True"/><CheckBox x:Name="chkUpdateExisting" Content="Update existing items" IsChecked="False"/><CheckBox x:Name="chkDryRun" Content="🧪 Dry Run (no changes)" IsChecked="False"/><CheckBox x:Name="chkUpdateImageUrls" Content="🔗 Update image URLs in content" IsChecked="True"/></WrapPanel></StackPanel></GroupBox>
<GroupBox Grid.Row="1" Header="📊 Import Source Summary" Margin="5"><Grid Margin="10"><Grid.ColumnDefinitions><ColumnDefinition Width="*"/><ColumnDefinition Width="*"/><ColumnDefinition Width="*"/><ColumnDefinition Width="*"/><ColumnDefinition Width="*"/><ColumnDefinition Width="*"/><ColumnDefinition Width="Auto"/></Grid.ColumnDefinitions><StackPanel Grid.Column="0" HorizontalAlignment="Center"><TextBlock Text="Shelves" Foreground="#666" HorizontalAlignment="Center"/><TextBlock x:Name="txtImportShelvesCount" Text="--" FontSize="24" Foreground="#ff8c00" HorizontalAlignment="Center"/></StackPanel><StackPanel Grid.Column="1" HorizontalAlignment="Center"><TextBlock Text="Books" Foreground="#666" HorizontalAlignment="Center"/><TextBlock x:Name="txtImportBooksCount" Text="--" FontSize="24" Foreground="#ff8c00" HorizontalAlignment="Center"/></StackPanel><StackPanel Grid.Column="2" HorizontalAlignment="Center"><TextBlock Text="Chapters" Foreground="#666" HorizontalAlignment="Center"/><TextBlock x:Name="txtImportChaptersCount" Text="--" FontSize="24" Foreground="#ff8c00" HorizontalAlignment="Center"/></StackPanel><StackPanel Grid.Column="3" HorizontalAlignment="Center"><TextBlock Text="Pages" Foreground="#666" HorizontalAlignment="Center"/><TextBlock x:Name="txtImportPagesCount" Text="--" FontSize="24" Foreground="#ff8c00" HorizontalAlignment="Center"/></StackPanel><StackPanel Grid.Column="4" HorizontalAlignment="Center"><TextBlock Text="Attachments" Foreground="#666" HorizontalAlignment="Center"/><TextBlock x:Name="txtImportAttachmentsCount" Text="--" FontSize="24" Foreground="#ff8c00" HorizontalAlignment="Center"/></StackPanel><StackPanel Grid.Column="5" HorizontalAlignment="Center"><TextBlock Text="Images" Foreground="#666" HorizontalAlignment="Center"/><TextBlock x:Name="txtImportImagesCount" Text="--" FontSize="24" Foreground="#ff8c00" HorizontalAlignment="Center"/></StackPanel><StackPanel Grid.Column="6" VerticalAlignment="Center"><Button x:Name="btnLoadExportData" Content="📂 Load Export" Background="#505050"/></StackPanel></Grid></GroupBox>
<GroupBox Grid.Row="2" Header="📋 Import Log" Margin="5"><Grid><Grid.RowDefinitions><RowDefinition Height="Auto"/><RowDefinition Height="*"/></Grid.RowDefinitions><StackPanel Grid.Row="0" Margin="10,10,10,5"><TextBlock x:Name="txtImportCurrentItem" Text="Ready to import..." Foreground="#1e1e1e"/><ProgressBar x:Name="progressImport" Height="20" Margin="0,5,0,0" Background="#e0e0e0" Foreground="#ff8c00" Value="0" Maximum="100"/><TextBlock x:Name="txtImportProgress" Text="0%" HorizontalAlignment="Center" Foreground="#666" Margin="0,3,0,0"/></StackPanel><TextBox x:Name="txtImportLog" Grid.Row="1" IsReadOnly="True" VerticalScrollBarVisibility="Auto" HorizontalScrollBarVisibility="Auto" TextWrapping="Wrap" FontFamily="Consolas" FontSize="11" Background="#ffffff" Margin="10,5,10,10"/></Grid></GroupBox>
<StackPanel Grid.Row="3" Orientation="Horizontal" HorizontalAlignment="Right" Margin="5"><Button x:Name="btnImport" Content="▶️ Start Import" Width="150" Background="#ff8c00"/><Button x:Name="btnCancelImport" Content="⏹️ Cancel" Width="100" Background="#d41a1a" IsEnabled="False"/></StackPanel></Grid></TabItem>
<TabItem Header="🗑️ Delete" Background="#e8e8e8" Foreground="#1e1e1e"><Grid Margin="10"><Grid.RowDefinitions><RowDefinition Height="Auto"/><RowDefinition Height="Auto"/><RowDefinition Height="*"/><RowDefinition Height="Auto"/></Grid.RowDefinitions>
<GroupBox Grid.Row="0" Header="⚠️ Delete Content from Target Instance" Margin="5" BorderBrush="#d41a1a"><StackPanel Margin="10"><TextBlock Text="WARNING: This will permanently delete content from the TARGET instance!" Foreground="#d41a1a" FontWeight="Bold" FontSize="14"/><TextBlock Text="Use this to clean up test imports or start fresh. Select a shelf to delete it and ALL its books, chapters, and pages." Foreground="#666" Margin="0,5,0,0" TextWrapping="Wrap"/></StackPanel></GroupBox>
<GroupBox Grid.Row="1" Header="Select Shelf to Delete" Margin="5"><Grid Margin="10"><Grid.ColumnDefinitions><ColumnDefinition Width="*"/><ColumnDefinition Width="Auto"/><ColumnDefinition Width="Auto"/></Grid.ColumnDefinitions><ComboBox x:Name="cmbShelves" DisplayMemberPath="name" Grid.Column="0" Height="30" FontSize="13" Background="#ffffff"/><Button x:Name="btnRefreshShelves" Grid.Column="1" Content="🔄 Refresh" Width="100" Background="#505050"/><Button x:Name="btnDeleteShelf" Grid.Column="2" Content="🗑️ Delete Shelf" Width="150" Background="#d41a1a"/></Grid></GroupBox>
<GroupBox Grid.Row="2" Header="📋 Delete Log" Margin="5"><Grid><Grid.RowDefinitions><RowDefinition Height="Auto"/><RowDefinition Height="*"/></Grid.RowDefinitions><StackPanel Grid.Row="0" Margin="10,10,10,5"><TextBlock x:Name="txtDeleteCurrentItem" Text="Select a shelf to delete..." Foreground="#1e1e1e"/><ProgressBar x:Name="progressDelete" Height="20" Margin="0,5,0,0" Background="#e0e0e0" Foreground="#d41a1a" Value="0" Maximum="100"/><TextBlock x:Name="txtDeleteProgress" Text="0%" HorizontalAlignment="Center" Foreground="#666" Margin="0,3,0,0"/></StackPanel><TextBox x:Name="txtDeleteLog" Grid.Row="1" IsReadOnly="True" VerticalScrollBarVisibility="Auto" HorizontalScrollBarVisibility="Auto" TextWrapping="Wrap" FontFamily="Consolas" FontSize="11" Background="#ffffff" Margin="10,5,10,10"/></Grid></GroupBox>
<StackPanel Grid.Row="3" Orientation="Horizontal" HorizontalAlignment="Right" Margin="5"><Button x:Name="btnDeleteAllShelves" Content="☢️ Delete ALL Shelves" Width="180" Background="#8b0000"/><Button x:Name="btnCancelDelete" Content="⏹️ Cancel" Width="100" Background="#d41a1a" IsEnabled="False"/></StackPanel></Grid></TabItem>
<TabItem Header="⚙️ Settings" Background="#e8e8e8" Foreground="#1e1e1e"><ScrollViewer VerticalScrollBarVisibility="Auto"><StackPanel Margin="15"><GroupBox Header="API Settings" Margin="5"><StackPanel Margin="10"><Label Content="Request Delay (milliseconds):"/><TextBox x:Name="txtRequestDelay" Text="600" Width="100" HorizontalAlignment="Left"/><TextBlock Text="Delay between API requests to avoid rate limiting" Foreground="#666" FontSize="11" Margin="0,3,0,0"/><Label Content="Batch Size:" Margin="0,15,0,0"/><TextBox x:Name="txtBatchSize" Text="100" Width="100" HorizontalAlignment="Left"/><TextBlock Text="Number of items to fetch per API request (max 500)" Foreground="#666" FontSize="11" Margin="0,3,0,0"/><Label Content="Timeout (seconds):" Margin="0,15,0,0"/><TextBox x:Name="txtTimeout" Text="300" Width="100" HorizontalAlignment="Left"/><Label Content="Max Retries:" Margin="0,15,0,0"/><TextBox x:Name="txtMaxRetries" Text="3" Width="100" HorizontalAlignment="Left"/></StackPanel></GroupBox>
<GroupBox Header="Logging" Margin="5"><StackPanel Margin="10"><CheckBox x:Name="chkVerboseLogging" Content="Verbose logging" IsChecked="True"/><CheckBox x:Name="chkConsoleDebug" Content="Console debug output" IsChecked="True"/><CheckBox x:Name="chkSaveLogToFile" Content="Save log to file" IsChecked="True"/></StackPanel></GroupBox></StackPanel></ScrollViewer></TabItem>
<TabItem Header="❓ Help" Background="#e8e8e8" Foreground="#1e1e1e"><ScrollViewer VerticalScrollBarVisibility="Auto"><StackPanel Margin="20"><TextBlock Text="BookStack Migration Tool - Help" FontSize="24" Foreground="#1e1e1e" Margin="0,0,0,20"/><TextBlock Text="🗑️ Delete Feature" FontSize="16" Foreground="#d41a1a" Margin="0,0,0,10"/><TextBlock TextWrapping="Wrap" Foreground="#1e1e1e" Margin="0,0,0,20">• Go to Delete tab to remove shelves and all their content&#x0a;• Click Refresh to load shelves from target instance&#x0a;• Select a shelf and click Delete to remove it&#x0a;• Use Delete ALL Shelves to completely clean the instance&#x0a;• All books, chapters, pages within deleted shelves are removed</TextBlock><TextBlock Text="📤 Export Process" FontSize="16" Foreground="#0078d4" Margin="0,0,0,10"/><TextBlock TextWrapping="Wrap" Foreground="#1e1e1e" Margin="0,0,0,20">1. Configure source connection and test it&#x0a;2. Select export path and content types&#x0a;3. Click Start Export to begin</TextBlock><TextBlock Text="📥 Import Process" FontSize="16" Foreground="#0078d4" Margin="0,0,0,10"/><TextBlock TextWrapping="Wrap" Foreground="#1e1e1e">1. Configure target connection and test it&#x0a;2. Load the exported data&#x0a;3. Click Start Import to begin migration</TextBlock></StackPanel></ScrollViewer></TabItem>
</TabControl>
<Border Grid.Row="2" Background="#e8e8e8" Padding="10,8"><Grid><Grid.ColumnDefinitions><ColumnDefinition Width="*"/><ColumnDefinition Width="Auto"/></Grid.ColumnDefinitions><TextBlock x:Name="txtFooterStatus" Text="Ready" Foreground="#666"/><TextBlock Grid.Column="1" Text="BookStack Migration Tool v2.5" Foreground="#999"/></Grid></Border>
</Grid>
</Window>
"@
Write-DebugLog "XAML definition loaded" -Level "SUCCESS"; Write-DebugLog "Creating XAML reader..." -Level "DEBUG"
try { $reader = New-Object System.Xml.XmlNodeReader $XAML; $Window = [Windows.Markup.XamlReader]::Load($reader); Write-DebugLog "Window created successfully" -Level "SUCCESS" } catch { Write-DebugLog "Failed to create window: $_" -Level "ERROR"; throw }
Write-DebugLog "Getting named controls..." -Level "DEBUG"; $controlCount = 0; $XAML.SelectNodes("//*[@*[contains(translate(name(.),'x','X'),'Name')]]") | ForEach-Object { $controlName = $_.Name; try { Set-Variable -Name $controlName -Value $Window.FindName($controlName) -Scope Script; $controlCount++ } catch { Write-DebugLog "Failed to get control: $controlName - $_" -Level "WARN" } }; Write-DebugLog "Loaded $controlCount controls" -Level "SUCCESS"
Write-DebugLog "Initializing global variables..." -Level "DEBUG"; $script:CancelExport = $false; $script:CancelImport = $false; $script:CancelDelete = $false; $script:ExportJob = $null; $script:ImportJob = $null; $script:DeleteJob = $null; $script:ExportTimer = $null; $script:ImportTimer = $null; $script:DeleteTimer = $null; $script:SourceApiCapabilities = @{}; $script:TargetApiCapabilities = @{}; $script:ExportedData = @{ Shelves = @(); Books = @(); Chapters = @(); Pages = @(); Attachments = @(); Images = @() }; $script:TargetShelves = @(); Write-DebugLog "Global variables initialized" -Level "SUCCESS"
function Get-SafeIntValue { param([System.Windows.Controls.TextBox]$TextBox, [int]$DefaultValue = 600); try { $text = $TextBox.Text; if ([string]::IsNullOrWhiteSpace($text)) { return $DefaultValue }; return [int]::Parse($text.Trim()) } catch { return $DefaultValue } }
function Write-UILog { param([string]$Message, [string]$Level = "INFO", [System.Windows.Controls.TextBox]$LogBox = $null); $timestamp = Get-Date -Format "HH:mm:ss"; $prefix = switch ($Level) { "ERROR" { "❌" } "WARN" { "⚠️" } "SUCCESS" { "✅" } "INFO" { "ℹ️" } "DEBUG" { "🔧" } default { "•" } }; $logMessage = "[$timestamp] $prefix $Message`r`n"; if ($script:chkConsoleDebug -and $script:chkConsoleDebug.IsChecked) { Write-DebugLog $Message -Level $Level }; if ($LogBox) { try { $Window.Dispatcher.Invoke([action]{ $LogBox.AppendText($logMessage); $LogBox.ScrollToEnd() }, [System.Windows.Threading.DispatcherPriority]::Background) } catch { Write-DebugLog "Failed to write to UI log: $_" -Level "ERROR" } } }
function Invoke-BookStackApiDirect { param([string]$BaseUrl, [string]$TokenId, [string]$TokenSecret, [string]$Endpoint, [string]$Method = "GET", [hashtable]$Body = $null, [int]$TimeoutSec = 300, [int]$DelayMs = 600); $uri = "$($BaseUrl.TrimEnd('/'))/$Endpoint"; Write-DebugLog "API Call: $Method $uri" -Level "DEBUG"; $headers = @{ "Authorization" = "Token $($TokenId):$($TokenSecret)" }; if ($Method -ne "GET" -and $Body) { $headers["Content-Type"] = "application/json" }; try { if ($DelayMs -gt 0) { Start-Sleep -Milliseconds $DelayMs }; $params = @{ Uri = $uri; Method = $Method; Headers = $headers; TimeoutSec = $TimeoutSec; UseBasicParsing = $true; ErrorAction = "Stop" }; if ($Body) { $jsonBody = $Body | ConvertTo-Json -Depth 10 -Compress; $params.Body = $jsonBody }; $response = Invoke-RestMethod @params; return $response } catch { $errorMsg = $_.Exception.Message; Write-DebugLog "API Error: $errorMsg" -Level "ERROR"; throw } }
function Test-ApiEndpoint { param([string]$BaseUrl, [string]$TokenId, [string]$TokenSecret, [string]$Endpoint); Write-DebugLog "Testing endpoint: $Endpoint" -Level "DEBUG"; try { $response = Invoke-BookStackApiDirect -BaseUrl $BaseUrl -TokenId $TokenId -TokenSecret $TokenSecret -Endpoint "$Endpoint`?count=1" -DelayMs 100; $result = @{ Available = $true; Total = $response.total; Error = $null }; Write-DebugLog "Endpoint $Endpoint available, total: $($response.total)" -Level "SUCCESS"; return $result } catch { $result = @{ Available = $false; Total = 0; Error = $_.Exception.Message }; Write-DebugLog "Endpoint $Endpoint not available: $($_.Exception.Message)" -Level "WARN"; return $result } }
Write-DebugLog "Setting up event handlers..." -Level "DEBUG"
$btnBrowse.Add_Click({ Write-DebugLog "Browse button clicked" -Level "DEBUG"; $folderBrowser = New-Object System.Windows.Forms.FolderBrowserDialog; $folderBrowser.Description = "Select export folder"; $folderBrowser.ShowNewFolderButton = $true; if ($folderBrowser.ShowDialog() -eq [System.Windows.Forms.DialogResult]::OK) { $txtExportPath.Text = $folderBrowser.SelectedPath; Write-DebugLog "Export path set to: $($folderBrowser.SelectedPath)" -Level "INFO" } })
$btnClearLog.Add_Click({ Write-DebugLog "Clearing console..." -Level "DEBUG"; Clear-Host; Write-DebugLog "Console cleared, starting fresh..." -Level "INFO" })
$btnTestSource.Add_Click({ Write-DebugLog "Testing source connection..." -Level "INFO"; $txtSourceStatus.Text = "Testing..."; $txtSourceStatus.Foreground = [System.Windows.Media.Brushes]::Orange; $baseUrl = $txtSourceUrl.Text.Trim(); $tokenId = $txtSourceTokenId.Text.Trim(); $tokenSecret = $txtSourceTokenSecret.Password; if ([string]::IsNullOrEmpty($baseUrl) -or [string]::IsNullOrEmpty($tokenId) -or [string]::IsNullOrEmpty($tokenSecret)) { $txtSourceStatus.Text = "Fill all fields"; $txtSourceStatus.Foreground = [System.Windows.Media.Brushes]::Red; return }; $endpoints = @( @{ Key = "books"; Control = $apiBooks; Name = "Books" }, @{ Key = "chapters"; Control = $apiChapters; Name = "Chapters" }, @{ Key = "pages"; Control = $apiPages; Name = "Pages" }, @{ Key = "shelves"; Control = $apiShelves; Name = "Shelves" }, @{ Key = "attachments"; Control = $apiAttachments; Name = "Attachments" } ); $hasBasicApis = $true; foreach ($ep in $endpoints) { $result = Test-ApiEndpoint -BaseUrl $baseUrl -TokenId $tokenId -TokenSecret $tokenSecret -Endpoint "api/$($ep.Key)"; $script:SourceApiCapabilities[$ep.Key] = $result; if ($result.Available) { $ep.Control.Text = "✅ $($ep.Name) ($($result.Total))"; $ep.Control.Foreground = [System.Windows.Media.Brushes]::Green } else { $ep.Control.Text = "❌ $($ep.Name)"; $ep.Control.Foreground = [System.Windows.Media.Brushes]::Red; if ($ep.Key -in @("books", "chapters", "pages")) { $hasBasicApis = $false } } }; $imgResult = Test-ApiEndpoint -BaseUrl $baseUrl -TokenId $tokenId -TokenSecret $tokenSecret -Endpoint "api/image-gallery"; $script:SourceApiCapabilities["images"] = $imgResult; if ($imgResult.Available) { $apiImages.Text = "✅ Images ($($imgResult.Total))"; $apiImages.Foreground = [System.Windows.Media.Brushes]::Green } else { $apiImages.Text = "⚠️ Images (N/A)"; $apiImages.Foreground = [System.Windows.Media.Brushes]::Orange }; $version = "Unknown"; if ($script:SourceApiCapabilities["images"].Available) { $version = "2023+ (Full API)" } elseif ($script:SourceApiCapabilities["shelves"].Available) { $version = "0.25+ (With Shelves)" } elseif ($hasBasicApis) { $version = "0.22-0.24 (Basic API)" }; $txtSourceVersion.Text = $version; if ($hasBasicApis) { $txtSourceStatus.Text = "Connected ✓"; $txtSourceStatus.Foreground = [System.Windows.Media.Brushes]::Green } else { $txtSourceStatus.Text = "Connection failed"; $txtSourceStatus.Foreground = [System.Windows.Media.Brushes]::Red } })
$btnTestTarget.Add_Click({ Write-DebugLog "Testing target connection..." -Level "INFO"; $txtTargetStatus.Text = "Testing..."; $txtTargetStatus.Foreground = [System.Windows.Media.Brushes]::Orange; $baseUrl = $txtTargetUrl.Text.Trim(); $tokenId = $txtTargetTokenId.Text.Trim(); $tokenSecret = $txtTargetTokenSecret.Password; if ([string]::IsNullOrEmpty($baseUrl) -or [string]::IsNullOrEmpty($tokenId) -or [string]::IsNullOrEmpty($tokenSecret)) { $txtTargetStatus.Text = "Fill all fields"; $txtTargetStatus.Foreground = [System.Windows.Media.Brushes]::Red; return }; $endpoints = @( @{ Key = "books"; Control = $apiTargetBooks; Name = "Books" }, @{ Key = "chapters"; Control = $apiTargetChapters; Name = "Chapters" }, @{ Key = "pages"; Control = $apiTargetPages; Name = "Pages" }, @{ Key = "shelves"; Control = $apiTargetShelves; Name = "Shelves" }, @{ Key = "attachments"; Control = $apiTargetAttachments; Name = "Attachments" } ); $hasBasicApis = $true; foreach ($ep in $endpoints) { $result = Test-ApiEndpoint -BaseUrl $baseUrl -TokenId $tokenId -TokenSecret $tokenSecret -Endpoint "api/$($ep.Key)"; $script:TargetApiCapabilities[$ep.Key] = $result; if ($result.Available) { $ep.Control.Text = "✅ $($ep.Name)"; $ep.Control.Foreground = [System.Windows.Media.Brushes]::Green } else { $ep.Control.Text = "❌ $($ep.Name)"; $ep.Control.Foreground = [System.Windows.Media.Brushes]::Red; if ($ep.Key -in @("books", "chapters", "pages")) { $hasBasicApis = $false } } }; $imgResult = Test-ApiEndpoint -BaseUrl $baseUrl -TokenId $tokenId -TokenSecret $tokenSecret -Endpoint "api/image-gallery"; $script:TargetApiCapabilities["images"] = $imgResult; if ($imgResult.Available) { $apiTargetImages.Text = "✅ Images"; $apiTargetImages.Foreground = [System.Windows.Media.Brushes]::Green } else { $apiTargetImages.Text = "⚠️ Images"; $apiTargetImages.Foreground = [System.Windows.Media.Brushes]::Orange }; $version = "Unknown"; if ($script:TargetApiCapabilities["images"].Available) { $version = "2023+ / 2025.11" } elseif ($script:TargetApiCapabilities["shelves"].Available) { $version = "0.25+" } elseif ($hasBasicApis) { $version = "0.22-0.24" }; $txtTargetVersion.Text = $version; if ($hasBasicApis) { $txtTargetStatus.Text = "Connected ✓"; $txtTargetStatus.Foreground = [System.Windows.Media.Brushes]::Green } else { $txtTargetStatus.Text = "Connection failed"; $txtTargetStatus.Foreground = [System.Windows.Media.Brushes]::Red } })
$btnRefreshCounts.Add_Click({ Write-DebugLog "Refreshing content counts..." -Level "INFO"; $baseUrl = $txtSourceUrl.Text.Trim(); $tokenId = $txtSourceTokenId.Text.Trim(); $tokenSecret = $txtSourceTokenSecret.Password; if ([string]::IsNullOrEmpty($tokenId)) { [System.Windows.MessageBox]::Show("Please configure and test source connection first", "Info", "OK", "Information"); return }; try { try { $shelves = Invoke-BookStackApiDirect -BaseUrl $baseUrl -TokenId $tokenId -TokenSecret $tokenSecret -Endpoint "api/shelves?count=1"; $txtShelvesCount.Text = $shelves.total.ToString() } catch { $txtShelvesCount.Text = "N/A" }; $books = Invoke-BookStackApiDirect -BaseUrl $baseUrl -TokenId $tokenId -TokenSecret $tokenSecret -Endpoint "api/books?count=1"; $txtBooksCount.Text = $books.total.ToString(); $chapters = Invoke-BookStackApiDirect -BaseUrl $baseUrl -TokenId $tokenId -TokenSecret $tokenSecret -Endpoint "api/chapters?count=1"; $txtChaptersCount.Text = $chapters.total.ToString(); $pages = Invoke-BookStackApiDirect -BaseUrl $baseUrl -TokenId $tokenId -TokenSecret $tokenSecret -Endpoint "api/pages?count=1"; $txtPagesCount.Text = $pages.total.ToString(); try { $attachments = Invoke-BookStackApiDirect -BaseUrl $baseUrl -TokenId $tokenId -TokenSecret $tokenSecret -Endpoint "api/attachments?count=1"; $txtAttachmentsCount.Text = $attachments.total.ToString() } catch { $txtAttachmentsCount.Text = "N/A" }; try { $images = Invoke-BookStackApiDirect -BaseUrl $baseUrl -TokenId $tokenId -TokenSecret $tokenSecret -Endpoint "api/image-gallery?count=1"; $txtImagesCount.Text = $images.total.ToString() } catch { $txtImagesCount.Text = "N/A" }; Write-DebugLog "Content counts refreshed" -Level "SUCCESS" } catch { Write-DebugLog "Failed to refresh counts: $_" -Level "ERROR"; [System.Windows.MessageBox]::Show("Failed to fetch counts: $_", "Error", "OK", "Error") } })
$btnSaveConfig.Add_Click({ Write-DebugLog "Saving configuration..." -Level "INFO"; $saveDialog = New-Object System.Windows.Forms.SaveFileDialog; $saveDialog.Filter = "JSON files (*.json)|*.json"; $saveDialog.DefaultExt = "json"; $saveDialog.FileName = "bookstack_migration_config.json"; if ($saveDialog.ShowDialog() -eq [System.Windows.Forms.DialogResult]::OK) { try { $config = @{ Source = @{ Url = $txtSourceUrl.Text; TokenId = $txtSourceTokenId.Text; TokenSecret = $txtSourceTokenSecret.Password }; Target = @{ Url = $txtTargetUrl.Text; TokenId = $txtTargetTokenId.Text; TokenSecret = $txtTargetTokenSecret.Password }; ExportPath = $txtExportPath.Text; Settings = @{ RequestDelay = $txtRequestDelay.Text; BatchSize = $txtBatchSize.Text; Timeout = $txtTimeout.Text; MaxRetries = $txtMaxRetries.Text } }; $config | ConvertTo-Json -Depth 10 | Out-File $saveDialog.FileName -Encoding UTF8; [System.Windows.MessageBox]::Show("Configuration saved!", "Success", "OK", "Information") } catch { [System.Windows.MessageBox]::Show("Failed to save: $_", "Error", "OK", "Error") } } })
$btnLoadConfig.Add_Click({ Write-DebugLog "Loading configuration..." -Level "INFO"; $openDialog = New-Object System.Windows.Forms.OpenFileDialog; $openDialog.Filter = "JSON files (*.json)|*.json"; if ($openDialog.ShowDialog() -eq [System.Windows.Forms.DialogResult]::OK) { try { $config = Get-Content $openDialog.FileName -Raw | ConvertFrom-Json; $txtSourceUrl.Text = $config.Source.Url; $txtSourceTokenId.Text = $config.Source.TokenId; $txtSourceTokenSecret.Password = $config.Source.TokenSecret; $txtTargetUrl.Text = $config.Target.Url; $txtTargetTokenId.Text = $config.Target.TokenId; $txtTargetTokenSecret.Password = $config.Target.TokenSecret; $txtExportPath.Text = $config.ExportPath; if ($config.Settings) { $txtRequestDelay.Text = $config.Settings.RequestDelay; $txtBatchSize.Text = $config.Settings.BatchSize; $txtTimeout.Text = $config.Settings.Timeout; if ($config.Settings.MaxRetries) { $txtMaxRetries.Text = $config.Settings.MaxRetries } }; [System.Windows.MessageBox]::Show("Configuration loaded!", "Success", "OK", "Information") } catch { [System.Windows.MessageBox]::Show("Failed to load: $_", "Error", "OK", "Error") } } })
$btnRefreshShelves.Add_Click({ Write-DebugLog "Refreshing shelves list..." -Level "INFO"; $baseUrl = $txtTargetUrl.Text.Trim(); $tokenId = $txtTargetTokenId.Text.Trim(); $tokenSecret = $txtTargetTokenSecret.Password; if ([string]::IsNullOrEmpty($tokenId)) { [System.Windows.MessageBox]::Show("Please configure and test target connection first", "Info", "OK", "Information"); return }; try { $cmbShelves.Items.Clear(); $response = Invoke-BookStackApiDirect -BaseUrl $baseUrl -TokenId $tokenId -TokenSecret $tokenSecret -Endpoint "api/shelves?count=500"; $script:TargetShelves = $response.data; foreach ($shelf in $response.data) { $cmbShelves.Items.Add($shelf) | Out-Null }; if ($cmbShelves.Items.Count -gt 0) { $cmbShelves.SelectedIndex = 0 }; Write-UILog "Found $($response.data.Count) shelves on target" -Level "SUCCESS" -LogBox $txtDeleteLog } catch { Write-DebugLog "Failed to get shelves: $_" -Level "ERROR"; [System.Windows.MessageBox]::Show("Failed to get shelves: $_", "Error", "OK", "Error") } })
$btnDeleteShelf.Add_Click({ $selectedShelf = $cmbShelves.SelectedItem; if ($null -eq $selectedShelf) { [System.Windows.MessageBox]::Show("Please select a shelf to delete", "Info", "OK", "Information"); return }; $confirm = [System.Windows.MessageBox]::Show("Are you sure you want to delete shelf '$($selectedShelf.name)' and ALL its contents?`n`nThis will delete all books, chapters, and pages within this shelf!`n`nThis action CANNOT be undone!", "Confirm Delete", "YesNo", "Warning"); if ($confirm -ne "Yes") { return }; $baseUrl = $txtTargetUrl.Text.Trim(); $tokenId = $txtTargetTokenId.Text.Trim(); $tokenSecret = $txtTargetTokenSecret.Password; $requestDelay = Get-SafeIntValue -TextBox $txtRequestDelay -DefaultValue 600; $timeout = Get-SafeIntValue -TextBox $txtTimeout -DefaultValue 300; $txtDeleteLog.Clear(); $btnDeleteShelf.IsEnabled = $false; $btnDeleteAllShelves.IsEnabled = $false; $btnCancelDelete.IsEnabled = $true; $progressDelete.Value = 0; Write-UILog "Starting deletion of shelf: $($selectedShelf.name)" -Level "INFO" -LogBox $txtDeleteLog; $script:DeleteJob = Start-Job -ScriptBlock { param([string]$BaseUrl, [string]$TokenId, [string]$TokenSecret, [int]$ShelfId, [string]$ShelfName, [int]$Delay, [int]$Timeout); $stats = @{ Pages = 0; Chapters = 0; Books = 0; Shelves = 0; Errors = 0 }; function Invoke-Api { param([string]$Endpoint, [string]$Method = "GET"); $headers = @{ "Authorization" = "Token $($TokenId):$($TokenSecret)"; "Content-Type" = "application/json" }; $uri = "$BaseUrl/api/$Endpoint"; Start-Sleep -Milliseconds $Delay; return Invoke-RestMethod -Uri $uri -Method $Method -Headers $headers -TimeoutSec $Timeout }; try { Write-Output "JOB_STATUS:Getting shelf details..."; $shelfDetail = Invoke-Api "shelves/$ShelfId"; $bookIds = @(); if ($shelfDetail.books) { foreach ($book in $shelfDetail.books) { $bookIds += $book.id } }; Write-Output "JOB_INFO:Found $($bookIds.Count) books in shelf"; foreach ($bookId in $bookIds) { try { Write-Output "JOB_STATUS:Processing book ID $bookId..."; $bookDetail = Invoke-Api "books/$bookId"; $bookName = $bookDetail.name; if ($bookDetail.contents) { foreach ($content in $bookDetail.contents) { if ($content.type -eq "page") { try { Invoke-Api "pages/$($content.id)" "DELETE" | Out-Null; $stats.Pages++; Write-Output "JOB_SUCCESS:Deleted page: $($content.name)" } catch { Write-Output "JOB_ERROR:Failed to delete page $($content.id): $_"; $stats.Errors++ } } elseif ($content.type -eq "chapter") { try { $chapterDetail = Invoke-Api "chapters/$($content.id)"; if ($chapterDetail.pages) { foreach ($page in $chapterDetail.pages) { try { Invoke-Api "pages/$($page.id)" "DELETE" | Out-Null; $stats.Pages++; Write-Output "JOB_SUCCESS:Deleted page: $($page.name)" } catch { Write-Output "JOB_ERROR:Failed to delete page $($page.id): $_"; $stats.Errors++ } } }; Invoke-Api "chapters/$($content.id)" "DELETE" | Out-Null; $stats.Chapters++; Write-Output "JOB_SUCCESS:Deleted chapter: $($content.name)" } catch { Write-Output "JOB_ERROR:Failed to delete chapter $($content.id): $_"; $stats.Errors++ } } } }; Invoke-Api "books/$bookId" "DELETE" | Out-Null; $stats.Books++; Write-Output "JOB_SUCCESS:Deleted book: $bookName" } catch { Write-Output "JOB_ERROR:Failed to process book $bookId : $_"; $stats.Errors++ } }; Invoke-Api "shelves/$ShelfId" "DELETE" | Out-Null; $stats.Shelves++; Write-Output "JOB_SUCCESS:Deleted shelf: $ShelfName"; Write-Output "JOB_COMPLETE:Deletion complete! Pages=$($stats.Pages) Chapters=$($stats.Chapters) Books=$($stats.Books) Shelves=$($stats.Shelves) Errors=$($stats.Errors)"; return $stats } catch { Write-Output "JOB_FATAL:Delete failed: $_"; throw } } -ArgumentList $baseUrl, $tokenId, $tokenSecret, $selectedShelf.id, $selectedShelf.name, $requestDelay, $timeout; $script:DeleteTimer = New-Object System.Windows.Threading.DispatcherTimer; $script:DeleteTimer.Interval = [TimeSpan]::FromMilliseconds(500); $script:DeleteTimer.Add_Tick({ if ($null -eq $script:DeleteJob) { $script:DeleteTimer.Stop(); return }; $output = Receive-Job -Job $script:DeleteJob -ErrorAction SilentlyContinue; foreach ($line in $output) { if ($line -is [string]) { if ($line -match "^JOB_STATUS:(.+)") { $txtDeleteCurrentItem.Text = $matches[1]; Write-UILog $matches[1] -Level "INFO" -LogBox $txtDeleteLog } elseif ($line -match "^JOB_INFO:(.+)") { Write-UILog $matches[1] -Level "INFO" -LogBox $txtDeleteLog } elseif ($line -match "^JOB_SUCCESS:(.+)") { Write-UILog $matches[1] -Level "SUCCESS" -LogBox $txtDeleteLog } elseif ($line -match "^JOB_ERROR:(.+)") { Write-UILog $matches[1] -Level "ERROR" -LogBox $txtDeleteLog } elseif ($line -match "^JOB_COMPLETE:(.+)") { Write-UILog $matches[1] -Level "SUCCESS" -LogBox $txtDeleteLog; $progressDelete.Value = 100; $txtDeleteProgress.Text = "100%" } elseif ($line -match "^JOB_FATAL:(.+)") { Write-UILog $matches[1] -Level "ERROR" -LogBox $txtDeleteLog } } }; if ($script:DeleteJob.State -eq 'Completed' -or $script:DeleteJob.State -eq 'Failed') { $script:DeleteTimer.Stop(); $txtDeleteCurrentItem.Text = "Deletion finished"; $btnDeleteShelf.IsEnabled = $true; $btnDeleteAllShelves.IsEnabled = $true; $btnCancelDelete.IsEnabled = $false; Remove-Job -Job $script:DeleteJob -Force -ErrorAction SilentlyContinue; $script:DeleteJob = $null; $btnRefreshShelves.RaiseEvent((New-Object System.Windows.RoutedEventArgs([System.Windows.Controls.Button]::ClickEvent))) } }); $script:DeleteTimer.Start() })
$btnDeleteAllShelves.Add_Click({ $confirm = [System.Windows.MessageBox]::Show("⚠️ DANGER: This will delete ALL SHELVES and ALL their contents!`n`nThis includes ALL books, chapters, and pages on the target instance!`n`nAre you ABSOLUTELY sure?", "CONFIRM DELETE ALL", "YesNo", "Warning"); if ($confirm -ne "Yes") { return }; $confirm2 = [System.Windows.MessageBox]::Show("FINAL WARNING: Type 'DELETE' in your mind and click Yes to proceed.`n`nThis action CANNOT be undone!", "FINAL CONFIRMATION", "YesNo", "Stop"); if ($confirm2 -ne "Yes") { return }; $baseUrl = $txtTargetUrl.Text.Trim(); $tokenId = $txtTargetTokenId.Text.Trim(); $tokenSecret = $txtTargetTokenSecret.Password; $requestDelay = Get-SafeIntValue -TextBox $txtRequestDelay -DefaultValue 600; $timeout = Get-SafeIntValue -TextBox $txtTimeout -DefaultValue 300; $txtDeleteLog.Clear(); $btnDeleteShelf.IsEnabled = $false; $btnDeleteAllShelves.IsEnabled = $false; $btnCancelDelete.IsEnabled = $true; $progressDelete.Value = 0; Write-UILog "Starting deletion of ALL shelves..." -Level "WARN" -LogBox $txtDeleteLog; $script:DeleteJob = Start-Job -ScriptBlock { param([string]$BaseUrl, [string]$TokenId, [string]$TokenSecret, [int]$Delay, [int]$Timeout); $stats = @{ Pages = 0; Chapters = 0; Books = 0; Shelves = 0; Errors = 0 }; function Invoke-Api { param([string]$Endpoint, [string]$Method = "GET"); $headers = @{ "Authorization" = "Token $($TokenId):$($TokenSecret)"; "Content-Type" = "application/json" }; $uri = "$BaseUrl/api/$Endpoint"; Start-Sleep -Milliseconds $Delay; return Invoke-RestMethod -Uri $uri -Method $Method -Headers $headers -TimeoutSec $Timeout }; try { Write-Output "JOB_STATUS:Getting all shelves..."; $shelvesResponse = Invoke-Api "shelves?count=500"; $shelves = $shelvesResponse.data; Write-Output "JOB_INFO:Found $($shelves.Count) shelves to delete"; foreach ($shelf in $shelves) { Write-Output "JOB_STATUS:Processing shelf: $($shelf.name)"; try { $shelfDetail = Invoke-Api "shelves/$($shelf.id)"; $bookIds = @(); if ($shelfDetail.books) { foreach ($book in $shelfDetail.books) { $bookIds += $book.id } }; foreach ($bookId in $bookIds) { try { $bookDetail = Invoke-Api "books/$bookId"; $bookName = $bookDetail.name; if ($bookDetail.contents) { foreach ($content in $bookDetail.contents) { if ($content.type -eq "page") { try { Invoke-Api "pages/$($content.id)" "DELETE" | Out-Null; $stats.Pages++ } catch { $stats.Errors++ } } elseif ($content.type -eq "chapter") { try { $chapterDetail = Invoke-Api "chapters/$($content.id)"; if ($chapterDetail.pages) { foreach ($page in $chapterDetail.pages) { try { Invoke-Api "pages/$($page.id)" "DELETE" | Out-Null; $stats.Pages++ } catch { $stats.Errors++ } } }; Invoke-Api "chapters/$($content.id)" "DELETE" | Out-Null; $stats.Chapters++ } catch { $stats.Errors++ } } } }; Invoke-Api "books/$bookId" "DELETE" | Out-Null; $stats.Books++; Write-Output "JOB_SUCCESS:Deleted book: $bookName" } catch { Write-Output "JOB_ERROR:Failed to delete book $bookId"; $stats.Errors++ } }; Invoke-Api "shelves/$($shelf.id)" "DELETE" | Out-Null; $stats.Shelves++; Write-Output "JOB_SUCCESS:Deleted shelf: $($shelf.name)" } catch { Write-Output "JOB_ERROR:Failed to delete shelf $($shelf.name): $_"; $stats.Errors++ } }; Write-Output "JOB_COMPLETE:All deletions complete! Pages=$($stats.Pages) Chapters=$($stats.Chapters) Books=$($stats.Books) Shelves=$($stats.Shelves) Errors=$($stats.Errors)"; return $stats } catch { Write-Output "JOB_FATAL:Delete all failed: $_"; throw } } -ArgumentList $baseUrl, $tokenId, $tokenSecret, $requestDelay, $timeout; $script:DeleteTimer = New-Object System.Windows.Threading.DispatcherTimer; $script:DeleteTimer.Interval = [TimeSpan]::FromMilliseconds(500); $script:DeleteTimer.Add_Tick({ if ($null -eq $script:DeleteJob) { $script:DeleteTimer.Stop(); return }; $output = Receive-Job -Job $script:DeleteJob -ErrorAction SilentlyContinue; foreach ($line in $output) { if ($line -is [string]) { if ($line -match "^JOB_STATUS:(.+)") { $txtDeleteCurrentItem.Text = $matches[1]; Write-UILog $matches[1] -Level "INFO" -LogBox $txtDeleteLog } elseif ($line -match "^JOB_INFO:(.+)") { Write-UILog $matches[1] -Level "INFO" -LogBox $txtDeleteLog } elseif ($line -match "^JOB_SUCCESS:(.+)") { Write-UILog $matches[1] -Level "SUCCESS" -LogBox $txtDeleteLog } elseif ($line -match "^JOB_ERROR:(.+)") { Write-UILog $matches[1] -Level "ERROR" -LogBox $txtDeleteLog } elseif ($line -match "^JOB_COMPLETE:(.+)") { Write-UILog $matches[1] -Level "SUCCESS" -LogBox $txtDeleteLog; $progressDelete.Value = 100; $txtDeleteProgress.Text = "100%" } elseif ($line -match "^JOB_FATAL:(.+)") { Write-UILog $matches[1] -Level "ERROR" -LogBox $txtDeleteLog } } }; if ($script:DeleteJob.State -eq 'Completed' -or $script:DeleteJob.State -eq 'Failed') { $script:DeleteTimer.Stop(); $txtDeleteCurrentItem.Text = "Deletion finished"; $btnDeleteShelf.IsEnabled = $true; $btnDeleteAllShelves.IsEnabled = $true; $btnCancelDelete.IsEnabled = $false; Remove-Job -Job $script:DeleteJob -Force -ErrorAction SilentlyContinue; $script:DeleteJob = $null } }); $script:DeleteTimer.Start() })
$btnCancelDelete.Add_Click({ Write-DebugLog "Cancel delete requested" -Level "WARN"; if ($script:DeleteJob) { Stop-Job -Job $script:DeleteJob -ErrorAction SilentlyContinue; Remove-Job -Job $script:DeleteJob -Force -ErrorAction SilentlyContinue; $script:DeleteJob = $null }; if ($null -ne $script:DeleteTimer) { $script:DeleteTimer.Stop() }; Write-UILog "Delete cancelled by user" -Level "WARN" -LogBox $txtDeleteLog; $btnDeleteShelf.IsEnabled = $true; $btnDeleteAllShelves.IsEnabled = $true; $btnCancelDelete.IsEnabled = $false; $txtDeleteCurrentItem.Text = "Delete cancelled" })
$btnExport.Add_Click({ Write-DebugLog "========== STARTING EXPORT ==========" -Level "INFO"; $baseUrl = $txtSourceUrl.Text.Trim(); $tokenId = $txtSourceTokenId.Text.Trim(); $tokenSecret = $txtSourceTokenSecret.Password; $exportPath = $txtExportPath.Text.Trim(); $requestDelay = Get-SafeIntValue -TextBox $txtRequestDelay -DefaultValue 600; $batchSize = Get-SafeIntValue -TextBox $txtBatchSize -DefaultValue 100; $timeout = Get-SafeIntValue -TextBox $txtTimeout -DefaultValue 300; $maxRetries = Get-SafeIntValue -TextBox $txtMaxRetries -DefaultValue 3; $exportShelves = $chkExportShelves.IsChecked; $exportBooks = $chkExportBooks.IsChecked; $exportChapters = $chkExportChapters.IsChecked; $exportPages = $chkExportPages.IsChecked; $exportAttachments = $chkExportAttachments.IsChecked; $exportImages = $chkExportImages.IsChecked; $downloadAttachmentFiles = $chkDownloadAttachmentFiles.IsChecked; $downloadImageFiles = $chkDownloadImageFiles.IsChecked; $exportCoverImages = $chkExportCoverImages.IsChecked; if ([string]::IsNullOrEmpty($tokenId) -or [string]::IsNullOrEmpty($exportPath)) { [System.Windows.MessageBox]::Show("Please configure source connection and export path", "Info", "OK", "Information"); return }; $directories = @($exportPath, "$exportPath\shelves", "$exportPath\books", "$exportPath\chapters", "$exportPath\pages", "$exportPath\attachments", "$exportPath\attachments\files", "$exportPath\images", "$exportPath\images\files", "$exportPath\covers", "$exportPath\logs"); foreach ($dir in $directories) { if (-not (Test-Path $dir)) { New-Item -ItemType Directory -Path $dir -Force | Out-Null } }; $txtExportLog.Clear(); $script:CancelExport = $false; $btnExport.IsEnabled = $false; $btnCancelExport.IsEnabled = $true; $progressExport.Value = 0; Write-UILog "Starting export..." -Level "INFO" -LogBox $txtExportLog; Write-UILog "Source: $baseUrl" -Level "INFO" -LogBox $txtExportLog; $exportOptions = @{ Shelves = $exportShelves; Books = $exportBooks; Chapters = $exportChapters; Pages = $exportPages; Attachments = $exportAttachments; Images = $exportImages; DownloadAttachments = $downloadAttachmentFiles; DownloadImages = $downloadImageFiles; ExportCoverImages = $exportCoverImages }; $script:ExportJob = Start-Job -ScriptBlock { param([string]$BaseUrl, [string]$TokenId, [string]$TokenSecret, [string]$ExportPath, [hashtable]$Options, [int]$BatchSize, [int]$Delay, [int]$Timeout, [int]$MaxRetries); $stats = @{ Shelves = 0; Books = 0; Chapters = 0; Pages = 0; Attachments = 0; Images = 0; Files = 0; Errors = 0 }; function Invoke-ApiWithRetry { param([string]$Endpoint, [string]$Method = "GET", [int]$Retries = $MaxRetries); $headers = @{ "Authorization" = "Token $($TokenId):$($TokenSecret)"; "Content-Type" = "application/json" }; $uri = "$BaseUrl/api/$Endpoint"; $attempt = 0; while ($attempt -lt $Retries) { try { Start-Sleep -Milliseconds $Delay; return Invoke-RestMethod -Uri $uri -Headers $headers -Method $Method -TimeoutSec $Timeout } catch { $attempt++; if ($attempt -ge $Retries) { throw $_ }; Start-Sleep -Milliseconds ($Delay * 2) } } }; function Download-File { param([string]$Url, [string]$OutputPath); try { $headers = @{ "Authorization" = "Token $($TokenId):$($TokenSecret)" }; if ($Url -notmatch "^https?://") { $Url = "$BaseUrl/$($Url.TrimStart('/'))" }; Start-Sleep -Milliseconds $Delay; Invoke-WebRequest -Uri $Url -Headers $headers -OutFile $OutputPath -TimeoutSec $Timeout -UseBasicParsing; return $true } catch { return $false } }; function Get-AllItems { param([string]$Endpoint); $items = @(); $offset = 0; $total = 0; do { try { $response = Invoke-ApiWithRetry "$Endpoint`?count=$BatchSize&offset=$offset"; $total = $response.total; $items += $response.data; $offset += $BatchSize; Write-Output "JOB_PROGRESS:Fetching $Endpoint - $($items.Count)/$total" } catch { break } } while ($items.Count -lt $total); return $items }; try { if ($Options.Shelves) { Write-Output "JOB_STATUS:Exporting shelves..."; try { $shelves = Get-AllItems "shelves"; $shelvesData = @(); foreach ($shelf in $shelves) { try { $detail = Invoke-ApiWithRetry "shelves/$($shelf.id)"; $shelvesData += $detail; $stats.Shelves++; Write-Output "JOB_ITEM:Shelf: $($shelf.name)"; if ($Options.ExportCoverImages -and $detail.cover) { $coverUrl = $detail.cover.url; if ($coverUrl) { $ext = [System.IO.Path]::GetExtension($coverUrl) -replace '\?.*$', ''; if (-not $ext) { $ext = ".jpg" }; $coverPath = "$ExportPath\covers\shelf_$($shelf.id)$ext"; if (Download-File -Url $coverUrl -OutputPath $coverPath) { $stats.Files++ } } } } catch { $stats.Errors++ } }; if ($shelvesData.Count -gt 0) { $shelvesData | ConvertTo-Json -Depth 20 | Out-File "$ExportPath\shelves\shelves.json" -Encoding UTF8; Write-Output "JOB_SUCCESS:Exported $($stats.Shelves) shelves" } } catch { Write-Output "JOB_WARN:Shelves API not available" } }; if ($Options.Books) { Write-Output "JOB_STATUS:Exporting books..."; $books = Get-AllItems "books"; $booksData = @(); foreach ($book in $books) { try { $detail = Invoke-ApiWithRetry "books/$($book.id)"; $booksData += $detail; $stats.Books++; Write-Output "JOB_ITEM:Book: $($book.name)"; $detail | ConvertTo-Json -Depth 20 | Out-File "$ExportPath\books\$($book.id).json" -Encoding UTF8; if ($Options.ExportCoverImages -and $detail.cover) { $coverUrl = $detail.cover.url; if ($coverUrl) { $ext = [System.IO.Path]::GetExtension($coverUrl) -replace '\?.*$', ''; if (-not $ext) { $ext = ".jpg" }; $coverPath = "$ExportPath\covers\book_$($book.id)$ext"; if (Download-File -Url $coverUrl -OutputPath $coverPath) { $stats.Files++ } } } } catch { $stats.Errors++ } }; if ($booksData.Count -gt 0) { $booksData | ConvertTo-Json -Depth 20 | Out-File "$ExportPath\books\books.json" -Encoding UTF8; Write-Output "JOB_SUCCESS:Exported $($stats.Books) books" } }; if ($Options.Chapters) { Write-Output "JOB_STATUS:Exporting chapters..."; $chapters = Get-AllItems "chapters"; $chaptersData = @(); foreach ($chapter in $chapters) { try { $detail = Invoke-ApiWithRetry "chapters/$($chapter.id)"; $chaptersData += $detail; $stats.Chapters++; Write-Output "JOB_ITEM:Chapter: $($chapter.name)"; $detail | ConvertTo-Json -Depth 20 | Out-File "$ExportPath\chapters\$($chapter.id).json" -Encoding UTF8 } catch { $stats.Errors++ } }; if ($chaptersData.Count -gt 0) { $chaptersData | ConvertTo-Json -Depth 20 | Out-File "$ExportPath\chapters\chapters.json" -Encoding UTF8; Write-Output "JOB_SUCCESS:Exported $($stats.Chapters) chapters" } }; if ($Options.Pages) { Write-Output "JOB_STATUS:Exporting pages..."; $pages = Get-AllItems "pages"; $pagesData = @(); $pageCount = 0; $totalPages = $pages.Count; foreach ($page in $pages) { $pageCount++; try { $detail = Invoke-ApiWithRetry "pages/$($page.id)"; $pagesData += $detail; $stats.Pages++; Write-Output "JOB_ITEM:Page ($pageCount/$totalPages): $($page.name)"; $detail | ConvertTo-Json -Depth 20 | Out-File "$ExportPath\pages\$($page.id).json" -Encoding UTF8 } catch { $stats.Errors++ } }; if ($pagesData.Count -gt 0) { $pagesData | ConvertTo-Json -Depth 20 | Out-File "$ExportPath\pages\pages.json" -Encoding UTF8; Write-Output "JOB_SUCCESS:Exported $($stats.Pages) pages" } }; if ($Options.Attachments) { Write-Output "JOB_STATUS:Exporting attachments..."; try { $attachments = Get-AllItems "attachments"; $attachmentsData = @(); foreach ($att in $attachments) { try { $detail = Invoke-ApiWithRetry "attachments/$($att.id)"; if ($Options.DownloadAttachments -and -not $detail.external) { if ($detail.content) { $fileName = if ($detail.name) { $detail.name } else { "attachment_$($att.id)" }; $fileName = $fileName -replace '[\\/:*?"<>|]', '_'; $ext = [System.IO.Path]::GetExtension($fileName); if (-not $ext -and $detail.extension) { $ext = ".$($detail.extension)"; $fileName = "$fileName$ext" }; $filePath = "$ExportPath\attachments\files\$($att.id)_$fileName"; try { [System.IO.File]::WriteAllBytes($filePath, [Convert]::FromBase64String($detail.content)); $detail | Add-Member -NotePropertyName "local_file" -NotePropertyValue "$($att.id)_$fileName" -Force; $stats.Files++ } catch { } } }; $attachmentsData += $detail; $stats.Attachments++; Write-Output "JOB_ITEM:Attachment: $($att.name)" } catch { $stats.Errors++ } }; if ($attachmentsData.Count -gt 0) { $attachmentsData | ConvertTo-Json -Depth 20 | Out-File "$ExportPath\attachments\attachments.json" -Encoding UTF8; Write-Output "JOB_SUCCESS:Exported $($stats.Attachments) attachments" } } catch { Write-Output "JOB_WARN:Attachments API not available" } }; if ($Options.Images) { Write-Output "JOB_STATUS:Exporting images..."; try { $images = Get-AllItems "image-gallery"; $imagesData = @(); $imgCount = 0; $totalImgs = $images.Count; foreach ($img in $images) { $imgCount++; try { $detail = Invoke-ApiWithRetry "image-gallery/$($img.id)"; if ($Options.DownloadImages -and $detail.url) { $imgUrl = $detail.url; $ext = [System.IO.Path]::GetExtension($imgUrl) -replace '\?.*$', ''; if (-not $ext) { $ext = ".png" }; $fileName = "$($img.id)$ext"; $filePath = "$ExportPath\images\files\$fileName"; if (Download-File -Url $imgUrl -OutputPath $filePath) { $detail | Add-Member -NotePropertyName "local_file" -NotePropertyValue $fileName -Force; $stats.Files++ } }; $imagesData += $detail; $stats.Images++; if ($imgCount % 10 -eq 0) { Write-Output "JOB_PROGRESS:Images: $imgCount/$totalImgs" } } catch { $stats.Errors++ } }; if ($imagesData.Count -gt 0) { $imagesData | ConvertTo-Json -Depth 20 | Out-File "$ExportPath\images\images.json" -Encoding UTF8; Write-Output "JOB_SUCCESS:Exported $($stats.Images) images" } } catch { Write-Output "JOB_WARN:Image gallery API not available" } }; $metadata = @{ ExportDate = (Get-Date -Format "yyyy-MM-dd HH:mm:ss"); SourceUrl = $BaseUrl; ExportVersion = "2.5"; Statistics = $stats; Options = $Options }; $metadata | ConvertTo-Json -Depth 10 | Out-File "$ExportPath\metadata.json" -Encoding UTF8; Write-Output "JOB_COMPLETE:Export completed! Shelves=$($stats.Shelves) Books=$($stats.Books) Chapters=$($stats.Chapters) Pages=$($stats.Pages) Attachments=$($stats.Attachments) Images=$($stats.Images) Files=$($stats.Files) Errors=$($stats.Errors)"; return $stats } catch { Write-Output "JOB_FATAL:Export failed: $_"; throw } } -ArgumentList $baseUrl, $tokenId, $tokenSecret, $exportPath, $exportOptions, $batchSize, $requestDelay, $timeout, $maxRetries; $script:ExportTimer = New-Object System.Windows.Threading.DispatcherTimer; $script:ExportTimer.Interval = [TimeSpan]::FromMilliseconds(500); $script:ExportTimer.Add_Tick({ if ($null -eq $script:ExportJob) { $script:ExportTimer.Stop(); return }; $output = Receive-Job -Job $script:ExportJob -ErrorAction SilentlyContinue; foreach ($line in $output) { if ($line -is [string]) { if ($line -match "^JOB_STATUS:(.+)") { $txtExportCurrentItem.Text = $matches[1]; Write-UILog $matches[1] -Level "INFO" -LogBox $txtExportLog } elseif ($line -match "^JOB_PROGRESS:(.+)") { $txtExportCurrentItem.Text = $matches[1] } elseif ($line -match "^JOB_ITEM:(.+)") { Write-UILog $matches[1] -Level "SUCCESS" -LogBox $txtExportLog } elseif ($line -match "^JOB_SUCCESS:(.+)") { Write-UILog $matches[1] -Level "SUCCESS" -LogBox $txtExportLog } elseif ($line -match "^JOB_WARN:(.+)") { Write-UILog $matches[1] -Level "WARN" -LogBox $txtExportLog } elseif ($line -match "^JOB_ERROR:(.+)") { Write-UILog $matches[1] -Level "ERROR" -LogBox $txtExportLog } elseif ($line -match "^JOB_COMPLETE:(.+)") { Write-UILog $matches[1] -Level "SUCCESS" -LogBox $txtExportLog; $progressExport.Value = 100; $txtExportProgress.Text = "100%" } elseif ($line -match "^JOB_FATAL:(.+)") { Write-UILog $matches[1] -Level "ERROR" -LogBox $txtExportLog } } }; if ($script:ExportJob.State -eq 'Completed' -or $script:ExportJob.State -eq 'Failed') { $script:ExportTimer.Stop(); $txtExportCurrentItem.Text = "Export finished"; $btnExport.IsEnabled = $true; $btnCancelExport.IsEnabled = $false; Remove-Job -Job $script:ExportJob -Force -ErrorAction SilentlyContinue; $script:ExportJob = $null } }); $script:ExportTimer.Start() })
$btnCancelExport.Add_Click({ Write-DebugLog "Cancel export requested" -Level "WARN"; $script:CancelExport = $true; if ($script:ExportJob) { Stop-Job -Job $script:ExportJob -ErrorAction SilentlyContinue; Remove-Job -Job $script:ExportJob -Force -ErrorAction SilentlyContinue; $script:ExportJob = $null }; if ($null -ne $script:ExportTimer) { $script:ExportTimer.Stop() }; Write-UILog "Export cancelled by user" -Level "WARN" -LogBox $txtExportLog; $btnExport.IsEnabled = $true; $btnCancelExport.IsEnabled = $false; $txtExportCurrentItem.Text = "Export cancelled" })
$btnLoadExportData.Add_Click({ Write-DebugLog "Loading export data..." -Level "INFO"; $exportPath = $txtExportPath.Text.Trim(); if (-not (Test-Path $exportPath)) { [System.Windows.MessageBox]::Show("Export path does not exist: $exportPath", "Error", "OK", "Error"); return }; $txtImportLog.Clear(); $progressImport.Value = 0; $txtImportProgress.Text = "0%"; Write-UILog "Validating export structure..." -Level "INFO" -LogBox $txtImportLog; if (-not (Test-Path "$exportPath\books\books.json")) { [System.Windows.MessageBox]::Show("Missing required file: books.json", "Validation Error", "OK", "Error"); return }; try { $metadataPath = "$exportPath\metadata.json"; if (Test-Path $metadataPath) { $metadata = Get-Content $metadataPath -Raw | ConvertFrom-Json; Write-UILog "Export source: $($metadata.SourceUrl)" -Level "INFO" -LogBox $txtImportLog; Write-UILog "Export date: $($metadata.ExportDate)" -Level "INFO" -LogBox $txtImportLog }; function Get-ItemCount { param([string]$Path); if (Test-Path $Path) { try { $data = Get-Content $Path -Raw | ConvertFrom-Json; if ($null -eq $data) { return 0 }; return if ($data -is [array]) { $data.Count } else { 1 } } catch { return 0 } }; return 0 }; $shelvesCount = Get-ItemCount "$exportPath\shelves\shelves.json"; $booksCount = Get-ItemCount "$exportPath\books\books.json"; $chaptersCount = Get-ItemCount "$exportPath\chapters\chapters.json"; $pagesCount = Get-ItemCount "$exportPath\pages\pages.json"; $attachmentsCount = Get-ItemCount "$exportPath\attachments\attachments.json"; $imagesCount = Get-ItemCount "$exportPath\images\images.json"; $txtImportShelvesCount.Text = $shelvesCount.ToString(); $txtImportBooksCount.Text = $booksCount.ToString(); $txtImportChaptersCount.Text = $chaptersCount.ToString(); $txtImportPagesCount.Text = $pagesCount.ToString(); $txtImportAttachmentsCount.Text = $attachmentsCount.ToString(); $txtImportImagesCount.Text = $imagesCount.ToString(); Write-UILog "Export data loaded successfully!" -Level "SUCCESS" -LogBox $txtImportLog; Write-UILog "Found: $shelvesCount shelves, $booksCount books, $chaptersCount chapters, $pagesCount pages, $attachmentsCount attachments, $imagesCount images" -Level "INFO" -LogBox $txtImportLog; $progressImport.Value = 100; $txtImportProgress.Text = "Ready to import" } catch { [System.Windows.MessageBox]::Show("Failed to load export data: $_", "Error", "OK", "Error") } })
$btnImport.Add_Click({ Write-DebugLog "========== STARTING IMPORT ==========" -Level "INFO"; $baseUrl = $txtTargetUrl.Text.Trim(); $tokenId = $txtTargetTokenId.Text.Trim(); $tokenSecret = $txtTargetTokenSecret.Password; $exportPath = $txtExportPath.Text.Trim(); $requestDelay = Get-SafeIntValue -TextBox $txtRequestDelay -DefaultValue 600; $timeout = Get-SafeIntValue -TextBox $txtTimeout -DefaultValue 300; $maxRetries = Get-SafeIntValue -TextBox $txtMaxRetries -DefaultValue 3; $dryRun = $chkDryRun.IsChecked; $skipExisting = $chkSkipExisting.IsChecked; $updateImageUrls = $chkUpdateImageUrls.IsChecked; $importOptions = @{ Shelves = $chkImportShelves.IsChecked; Books = $chkImportBooks.IsChecked; Chapters = $chkImportChapters.IsChecked; Pages = $chkImportPages.IsChecked; Attachments = $chkImportAttachments.IsChecked; Images = $chkImportImages.IsChecked; UpdateImageUrls = $updateImageUrls }; if ([string]::IsNullOrEmpty($tokenId)) { [System.Windows.MessageBox]::Show("Please configure target connection", "Info", "OK", "Information"); return }; if (-not (Test-Path "$exportPath\books\books.json")) { [System.Windows.MessageBox]::Show("Please load export data first", "Info", "OK", "Information"); return }; $txtImportLog.Clear(); $btnImport.IsEnabled = $false; $btnCancelImport.IsEnabled = $true; $progressImport.Value = 0; if ($dryRun) { Write-UILog "=== DRY RUN MODE ===" -Level "WARN" -LogBox $txtImportLog }; Write-UILog "Starting import to: $baseUrl" -Level "INFO" -LogBox $txtImportLog; $script:ImportJob = Start-Job -ScriptBlock { param([string]$BaseUrl, [string]$TokenId, [string]$TokenSecret, [string]$ExportPath, [hashtable]$Options, [bool]$DryRun, [bool]$SkipExisting, [int]$Delay, [int]$Timeout, [int]$MaxRetries); $idMap = @{ Shelves = @{}; Books = @{}; Chapters = @{}; Pages = @{}; Images = @{} }; $imageUrlMap = @{}; $stats = @{ Created = 0; Skipped = 0; Files = 0; Errors = 0 }; function Invoke-ApiWithRetry { param([string]$Endpoint, [string]$Method = "GET", [hashtable]$Body = $null, [int]$Retries = $MaxRetries); $headers = @{ "Authorization" = "Token $($TokenId):$($TokenSecret)"; "Content-Type" = "application/json" }; $uri = "$BaseUrl/api/$Endpoint"; $attempt = 0; while ($attempt -lt $Retries) { try { Start-Sleep -Milliseconds $Delay; $params = @{ Uri = $uri; Method = $Method; Headers = $headers; TimeoutSec = $Timeout; ErrorAction = "Stop" }; if ($Body) { $params.Body = ($Body | ConvertTo-Json -Depth 20 -Compress) }; return Invoke-RestMethod @params } catch { $attempt++; if ($attempt -ge $Retries) { throw $_ }; Start-Sleep -Milliseconds ($Delay * 2) } } }; function Invoke-MultipartUpload { param([string]$Endpoint, [hashtable]$Fields, [string]$FilePath = $null, [string]$FileFieldName = "file"); $uri = "$BaseUrl/api/$Endpoint"; try { Add-Type -AssemblyName System.Net.Http; $client = New-Object System.Net.Http.HttpClient; $client.DefaultRequestHeaders.Add("Authorization", "Token $($TokenId):$($TokenSecret)"); $client.Timeout = [TimeSpan]::FromSeconds($Timeout); $content = New-Object System.Net.Http.MultipartFormDataContent; foreach ($key in $Fields.Keys) { $stringContent = New-Object System.Net.Http.StringContent($Fields[$key].ToString()); $content.Add($stringContent, $key) }; if ($FilePath -and (Test-Path $FilePath)) { $fileStream = [System.IO.File]::OpenRead($FilePath); $fileContent = New-Object System.Net.Http.StreamContent($fileStream); $fileName = [System.IO.Path]::GetFileName($FilePath); $content.Add($fileContent, $FileFieldName, $fileName) }; Start-Sleep -Milliseconds $Delay; $response = $client.PostAsync($uri, $content).Result; if ($response.IsSuccessStatusCode) { $responseBody = $response.Content.ReadAsStringAsync().Result; return $responseBody | ConvertFrom-Json } else { $errorBody = $response.Content.ReadAsStringAsync().Result; throw "HTTP $($response.StatusCode): $errorBody" } } catch { throw $_ } finally { if ($fileStream) { $fileStream.Dispose() }; if ($client) { $client.Dispose() } } }; function Find-Existing { param([string]$Type, [string]$Name); try { $items = Invoke-ApiWithRetry "$Type`?count=500"; if ($null -eq $items -or $null -eq $items.data) { return $null }; return $items.data | Where-Object { $_.name -ieq $Name } | Select-Object -First 1 } catch { return $null } }; function Get-SafeString { param($Value); if ($null -eq $Value) { return "" }; return [string]$Value }; function Update-ContentImageUrls { param([string]$Content); if ([string]::IsNullOrEmpty($Content)) { return $Content }; foreach ($oldUrl in $imageUrlMap.Keys) { $newUrl = $imageUrlMap[$oldUrl]; $Content = $Content -replace [regex]::Escape($oldUrl), $newUrl }; return $Content }; try { if ($Options.Shelves) { $shelvesPath = "$ExportPath\shelves\shelves.json"; if (Test-Path $shelvesPath) { Write-Output "JOB_STATUS:Importing shelves..."; $shelves = Get-Content $shelvesPath -Raw | ConvertFrom-Json; if ($shelves -isnot [array]) { $shelves = @($shelves) }; foreach ($shelf in $shelves) { try { $shelfName = (Get-SafeString -Value $shelf.name).Trim(); if ([string]::IsNullOrWhiteSpace($shelfName)) { $stats.Errors++; continue }; if ($SkipExisting) { $existing = Find-Existing "shelves" $shelfName; if ($existing) { $idMap.Shelves[$shelf.id.ToString()] = $existing.id; $stats.Skipped++; Write-Output "JOB_SKIP:Shelf exists: $shelfName"; continue } }; if ($DryRun) { $idMap.Shelves[$shelf.id.ToString()] = -1; Write-Output "JOB_DRYRUN:Would create shelf: $shelfName" } else { $body = @{ name = $shelfName; description = Get-SafeString -Value $shelf.description }; $new = Invoke-ApiWithRetry "shelves" "POST" $body; if ($null -ne $new -and $null -ne $new.id) { $idMap.Shelves[$shelf.id.ToString()] = $new.id; $stats.Created++; Write-Output "JOB_SUCCESS:Created shelf: $shelfName" } } } catch { $stats.Errors++; Write-Output "JOB_ERROR:Failed to create shelf: $_" } }; Write-Output "JOB_SUCCESS:Shelves import complete" } }; if ($Options.Books) { $booksPath = "$ExportPath\books\books.json"; if (Test-Path $booksPath) { Write-Output "JOB_STATUS:Importing books..."; $books = Get-Content $booksPath -Raw | ConvertFrom-Json; if ($books -isnot [array]) { $books = @($books) }; foreach ($book in $books) { try { $bookName = (Get-SafeString -Value $book.name).Trim(); if ([string]::IsNullOrWhiteSpace($bookName)) { $stats.Errors++; continue }; if ($SkipExisting) { $existing = Find-Existing "books" $bookName; if ($existing) { $idMap.Books[$book.id.ToString()] = $existing.id; $stats.Skipped++; Write-Output "JOB_SKIP:Book exists: $bookName"; continue } }; if ($DryRun) { $idMap.Books[$book.id.ToString()] = -1; Write-Output "JOB_DRYRUN:Would create book: $bookName" } else { $body = @{ name = $bookName; description = Get-SafeString -Value $book.description }; $new = Invoke-ApiWithRetry "books" "POST" $body; if ($null -ne $new -and $null -ne $new.id) { $idMap.Books[$book.id.ToString()] = $new.id; $stats.Created++; Write-Output "JOB_SUCCESS:Created book: $bookName" } } } catch { $stats.Errors++; Write-Output "JOB_ERROR:Failed to create book: $_" } }; Write-Output "JOB_SUCCESS:Books import complete" } }; if ($Options.Chapters) { $chaptersPath = "$ExportPath\chapters\chapters.json"; if (Test-Path $chaptersPath) { Write-Output "JOB_STATUS:Importing chapters..."; $chapters = Get-Content $chaptersPath -Raw | ConvertFrom-Json; if ($chapters -isnot [array]) { $chapters = @($chapters) }; $chapters = $chapters | Sort-Object { if ($_.priority) { $_.priority } else { 0 } }; foreach ($chapter in $chapters) { try { $chapterName = (Get-SafeString -Value $chapter.name).Trim(); if ([string]::IsNullOrWhiteSpace($chapterName)) { $stats.Errors++; continue }; $newBookId = $idMap.Books[$chapter.book_id.ToString()]; if (-not $newBookId -or $newBookId -eq -1) { $stats.Errors++; continue }; if ($DryRun) { $idMap.Chapters[$chapter.id.ToString()] = -1; Write-Output "JOB_DRYRUN:Would create chapter: $chapterName" } else { $body = @{ book_id = $newBookId; name = $chapterName; description = Get-SafeString -Value $chapter.description }; if ($chapter.priority) { $body.priority = $chapter.priority }; $new = Invoke-ApiWithRetry "chapters" "POST" $body; if ($null -ne $new -and $null -ne $new.id) { $idMap.Chapters[$chapter.id.ToString()] = $new.id; $stats.Created++; Write-Output "JOB_SUCCESS:Created chapter: $chapterName" } } } catch { $stats.Errors++; Write-Output "JOB_ERROR:Failed to create chapter: $_" } }; Write-Output "JOB_SUCCESS:Chapters import complete" } }; if ($Options.Pages) { $pagesPath = "$ExportPath\pages\pages.json"; if (Test-Path $pagesPath) { Write-Output "JOB_STATUS:Importing pages..."; $pages = Get-Content $pagesPath -Raw | ConvertFrom-Json; if ($pages -isnot [array]) { $pages = @($pages) }; $pages = $pages | Sort-Object { if ($_.priority) { $_.priority } else { 0 } }; $pageNum = 0; $totalPages = $pages.Count; foreach ($page in $pages) { $pageNum++; try { $pageName = (Get-SafeString -Value $page.name).Trim(); if ([string]::IsNullOrWhiteSpace($pageName)) { $stats.Errors++; continue }; $newBookId = $idMap.Books[$page.book_id.ToString()]; $newChapterId = if ($page.chapter_id) { $idMap.Chapters[$page.chapter_id.ToString()] } else { $null }; if (-not $newBookId -or $newBookId -eq -1) { $stats.Errors++; continue }; if ($DryRun) { $idMap.Pages[$page.id.ToString()] = -1; Write-Output "JOB_DRYRUN:Would create page: $pageName" } else { $body = @{ name = $pageName }; if ($newChapterId -and $newChapterId -ne -1) { $body.chapter_id = $newChapterId } else { $body.book_id = $newBookId }; if ($page.priority) { $body.priority = $page.priority }; if ($page.markdown) { $body.markdown = Get-SafeString -Value $page.markdown } elseif ($page.html) { $body.html = Get-SafeString -Value $page.html } else { $body.html = "<p></p>" }; $new = Invoke-ApiWithRetry "pages" "POST" $body; if ($null -ne $new -and $null -ne $new.id) { $idMap.Pages[$page.id.ToString()] = $new.id; $stats.Created++; if ($pageNum % 10 -eq 0) { Write-Output "JOB_PROGRESS:Pages: $pageNum/$totalPages" } } } } catch { $stats.Errors++; Write-Output "JOB_ERROR:Failed to create page: $_" } }; Write-Output "JOB_SUCCESS:Pages import complete" } }; if ($Options.Shelves -and $Options.Books) { Write-Output "JOB_STATUS:Updating shelf-book relationships..."; $shelvesPath = "$ExportPath\shelves\shelves.json"; if ((Test-Path $shelvesPath) -and -not $DryRun) { try { $shelves = Get-Content $shelvesPath -Raw | ConvertFrom-Json; if ($shelves -isnot [array]) { $shelves = @($shelves) }; foreach ($shelf in $shelves) { $newShelfId = $idMap.Shelves[$shelf.id.ToString()]; if (-not $newShelfId -or $newShelfId -eq -1) { continue }; if ($shelf.books -and $shelf.books.Count -gt 0) { $bookIds = @(); foreach ($oldBook in $shelf.books) { $oldBookId = if ($oldBook.id) { $oldBook.id } else { $oldBook }; $newBookId = $idMap.Books[$oldBookId.ToString()]; if ($newBookId -and $newBookId -ne -1) { $bookIds += $newBookId } }; if ($bookIds.Count -gt 0) { try { $body = @{ books = $bookIds }; Invoke-ApiWithRetry "shelves/$newShelfId" "PUT" $body | Out-Null } catch { } } } } } catch { } } }; $mappingOutput = @{ ExportDate = (Get-Date -Format "yyyy-MM-dd HH:mm:ss"); TargetUrl = $BaseUrl; IdMappings = $idMap; Statistics = $stats }; $mappingOutput | ConvertTo-Json -Depth 10 | Out-File "$ExportPath\import_id_mapping.json" -Encoding UTF8; Write-Output "JOB_COMPLETE:Import completed! Created=$($stats.Created) Skipped=$($stats.Skipped) Files=$($stats.Files) Errors=$($stats.Errors)"; return $stats } catch { Write-Output "JOB_FATAL:Import failed: $_"; throw } } -ArgumentList $baseUrl, $tokenId, $tokenSecret, $exportPath, $importOptions, $dryRun, $skipExisting, $requestDelay, $timeout, $maxRetries; $script:ImportTimer = New-Object System.Windows.Threading.DispatcherTimer; $script:ImportTimer.Interval = [TimeSpan]::FromMilliseconds(500); $script:ImportTimer.Add_Tick({ if ($null -eq $script:ImportJob) { $script:ImportTimer.Stop(); return }; $output = Receive-Job -Job $script:ImportJob -ErrorAction SilentlyContinue; foreach ($line in $output) { if ($line -is [string]) { if ($line -match "^JOB_STATUS:(.+)") { $txtImportCurrentItem.Text = $matches[1]; Write-UILog $matches[1] -Level "INFO" -LogBox $txtImportLog } elseif ($line -match "^JOB_PROGRESS:(.+)") { $txtImportCurrentItem.Text = $matches[1]; Write-UILog $matches[1] -Level "INFO" -LogBox $txtImportLog } elseif ($line -match "^JOB_SUCCESS:(.+)") { Write-UILog $matches[1] -Level "SUCCESS" -LogBox $txtImportLog } elseif ($line -match "^JOB_SKIP:(.+)") { Write-UILog $matches[1] -Level "INFO" -LogBox $txtImportLog } elseif ($line -match "^JOB_DRYRUN:(.+)") { Write-UILog "[DRY RUN] $($matches[1])" -Level "WARN" -LogBox $txtImportLog } elseif ($line -match "^JOB_WARN:(.+)") { Write-UILog $matches[1] -Level "WARN" -LogBox $txtImportLog } elseif ($line -match "^JOB_ERROR:(.+)") { Write-UILog $matches[1] -Level "ERROR" -LogBox $txtImportLog } elseif ($line -match "^JOB_COMPLETE:(.+)") { Write-UILog $matches[1] -Level "SUCCESS" -LogBox $txtImportLog; $progressImport.Value = 100; $txtImportProgress.Text = "100%" } elseif ($line -match "^JOB_FATAL:(.+)") { Write-UILog $matches[1] -Level "ERROR" -LogBox $txtImportLog } } }; if ($script:ImportJob.State -eq 'Completed' -or $script:ImportJob.State -eq 'Failed') { $script:ImportTimer.Stop(); $txtImportCurrentItem.Text = "Import finished"; $btnImport.IsEnabled = $true; $btnCancelImport.IsEnabled = $false; Remove-Job -Job $script:ImportJob -Force -ErrorAction SilentlyContinue; $script:ImportJob = $null } }); $script:ImportTimer.Start() })
$btnCancelImport.Add_Click({ Write-DebugLog "Cancel import requested" -Level "WARN"; if ($script:ImportJob) { Stop-Job -Job $script:ImportJob -ErrorAction SilentlyContinue; Remove-Job -Job $script:ImportJob -Force -ErrorAction SilentlyContinue; $script:ImportJob = $null }; if ($null -ne $script:ImportTimer) { $script:ImportTimer.Stop() }; Write-UILog "Import cancelled by user" -Level "WARN" -LogBox $txtImportLog; $btnImport.IsEnabled = $true; $btnCancelImport.IsEnabled = $false; $txtImportCurrentItem.Text = "Import cancelled" })
$Window.Add_Closing({ Write-DebugLog "Window closing, cleaning up..." -Level "INFO"; if ($script:ExportJob) { Stop-Job -Job $script:ExportJob -ErrorAction SilentlyContinue; Remove-Job -Job $script:ExportJob -Force -ErrorAction SilentlyContinue }; if ($script:ImportJob) { Stop-Job -Job $script:ImportJob -ErrorAction SilentlyContinue; Remove-Job -Job $script:ImportJob -Force -ErrorAction SilentlyContinue }; if ($script:DeleteJob) { Stop-Job -Job $script:DeleteJob -ErrorAction SilentlyContinue; Remove-Job -Job $script:DeleteJob -Force -ErrorAction SilentlyContinue }; if ($null -ne $script:ExportTimer) { $script:ExportTimer.Stop() }; if ($null -ne $script:ImportTimer) { $script:ImportTimer.Stop() }; if ($null -ne $script:DeleteTimer) { $script:DeleteTimer.Stop() } })
Write-DebugLog "========================================" -Level "INFO"; Write-DebugLog "BookStack Migration Tool v2.5 Started" -Level "INFO"; Write-DebugLog "With Delete Feature" -Level "INFO"; Write-DebugLog "========================================" -Level "INFO"; Write-DebugLog "Showing main window..." -Level "DEBUG"; $Window.ShowDialog() | Out-Null; Write-DebugLog "Application closed" -Level "INFO"